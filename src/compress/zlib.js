// zlib format compatible buffer processor
// the zlib format is specified in RFC1950
import { DeflateCompressor } from './deflate';
import { Adler32Checksum } from './zlib-util/edler';

// Zlib format is a simple wrapper format of the raw compress stream generated by
// deflate algorithm. The file format can be illustrated as the following
// +---+---+   +---+---+---+---+  +============+---+---+---+---+
// |CMF|FLG|   |    DICT-ID    |  | compressed |    Adler-32   |
// +---+---+   +---+---+---+---+  +============+---+---+---+---+
//             (if FLG.DICT set)
const CM_DEFLATE = 8;
const C_INFO_DEFLATE_32K = 7; // 32KB window size for DEFLATE algorithm
const FLG_DICT_ON = 1;
const FLG_DICT_OFF = 0;
const compressionLevel = {
  fastest: 0,
  fast: 1,
  default: 2,
  maximum: 3,
};

export class ZlibCompressor {
  /**
   * @param {Uint8Array} msg
   */
  static decompress(msg) {
    if (msg.length < 6) {
      throw 'corrupted zlib message';
    }
    const cmf = msg[0];
    const flg = msg[1];

    // Header checksum
    if ((flg + cmf * 256) % 31 !== 0) throw 'zlib header check failed, buffer content might be corrupted';

    // Check compression method
    const cm = cmf & 0x0f;
    if (cm !== CM_DEFLATE) throw 'this implementation only support DEFLATE compression method';

    // for DEFLATE, the compression info indicates the window size (in base-2 logarithm)
    const compressionInfo = cmf >>> 4;
    if (compressionInfo > 7) throw 'window info size larger than 32K is not supported';

    const dictFlag = (flg >>> 5) & 1;

    const compressionLevel = (flg >>> 6) & 3;
    const dict = { length: 0 };
    if (dictFlag === FLG_DICT_ON) {
      const dictChecksum = msg[2] << 24 | msg[3] << 16 | msg[4] << 8 | msg[5];
      let pos = 5;
      for (let chk = new Adler32Checksum(); pos < msg.length && chk.adler !== dictChecksum; pos++) {
        chk.update(msg, pos, 1);
      }
      dict.dict = msg.slice(6, pos);
      dict.length = pos - 2;
    }

    const dataChecksum =
      msg[msg.length - 4] << 24 |
      msg[msg.length - 3] << 16 |
      msg[msg.length - 2] << 8 |
      msg[msg.length - 1];

    const data = DeflateCompressor.decompress(msg.slice(2 + dict.length, -4), {
      dict: dict.buffer,
      compressionLevel,
    });
    if (Adler32Checksum.getCheck(data) !== dataChecksum) {
      console.log(Adler32Checksum.getCheck(data));
      console.log(dataChecksum);
      throw `data checksum mismatch, data might be corrupted ${dataChecksum.toString(16)} ${Adler32Checksum.getCheck(data).toString(16)}`;
    }

    return data;
  }

  /**
   *
   * This implementation doesn't support predefined dictionary as specified in RFC1950
   *
   * @param {Uint8Array} msg Message to be compressed
   */
  static compress(msg, level = compressionLevel.default) {
    const cmf = CM_DEFLATE | (C_INFO_DEFLATE_32K << 4);
    const flag = (level << 6) | (FLG_DICT_OFF << 5);
    const flagChk = flag + 31 - (cmf * 256 + flag) % 31; // add header checksum
    const compressionData = DeflateCompressor.compress(msg);
    const adler32 = Adler32Checksum.getCheck(msg);

    const buffer = new Uint8Array(2 + compressionData.length + 4);
    buffer[0] = cmf;
    buffer[1] = flagChk;
    buffer.set(compressionData, 2);
    buffer[buffer.length - 4] = (adler32 >>> 24) & 0xff;
    buffer[buffer.length - 3] = (adler32 >>> 16) & 0xff;
    buffer[buffer.length - 2] = (adler32 >>> 8) & 0xff;
    buffer[buffer.length - 1] = (adler32 >>> 0) & 0xff;
    return buffer;
  }
}

export default ZlibCompressor;
